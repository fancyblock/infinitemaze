/** * Boids * Author: Andrew White <andrew@vohm.com> * * ActionScript 3.0 port of the NodeBox Boids library by * Tom De Smedt <tomdesmedt@trapdoor.be> * See: http://nodebox.net/code/index.php/Boids for info and usage. * * For the original pseucode the algorithm is based on: * http://www.vergenet.net/~conrad/boids/pseudocode.html**/ package com.vohm.boids {  public class Boids {    public var boids:Array;    public var w:Number; // width    public var h:Number; // height    public var d:Number; // depth    public var l:Number; // speed limit      public var scattered:Boolean = false;      private var __scatter:Number = 0.005;    private var __scatter_timer:uint = 50;    private var __scatter_i:uint = 0;        private var __perch:Number = 0;    private var __perch_y:Number = 0;    private var __perch_timer:uint = 0;      public var has_goal:Boolean = false;    public var flee:Boolean = false;     private var __gx:Number = 0;    private var __gy:Number = 0;    private var __gz:Number = 0;			public function Boids(n:uint, w:Number, h:Number, d:Number, l:Number = 10) {      this.boids = [];          var i:uint = 0      for (i; i < n; i ++) {        var dx:Number = Math.random() * w;        var dy:Number = Math.random() * h;        var dz:Number = Math.random() * d;              var b:Boid = new Boid(this.boids, dx, dy, dz);        this.boids.push(b);      }          this.w = w;      this.h = h;      this.d = d;      this.l = l;    }      public function scatter(chance:Number = 0.005, frames:uint = 50):void {      this.__scatter = chance;      this.__scatter_timer = frames;    } 				public function no_scatter():void {			this.__scatter = 0;		}       public function perch(ground:Number = 0, chance:Number = 1, frames:uint = 50):void {      this.__perch = chance;      this.__perch_y = ground;      this.__perch_timer = frames;    }        public function no_perch():void {      this.__perch = 0;    }	     public function goal(x:Number, y:Number, z:Number, flee:Boolean = false):void {      this.has_goal = true;      this.flee = flee      this.__gx = x;      this.__gy = y;      this.__gz = z;    }    public function no_goal():void {      this.has_goal = false;    }         private function constrain():void {      // Cages the flock inside the x, y, w, h area.            // The actual cage is a bit larger, so boids don't seem to bounce of       // invisible walls (they are rather "encouraged" to stay in the area).			// If a boid touches the ground level, it may decide to perch there for 			// a while.              var dx:Number = this.w * 0.1;      var dy:Number = this.h * 0.1;      var dz:Number = this.d * 0.1;                 for each (var b:Boid in this.boids) {        if (b.x < 0 - dx) {          b.vx += Math.random() * dx;        }        if (b.x > this.w + dx) {          b.vx -= Math.random() * dx;        }                if (b.y < 0 - dy) {          b.vy += Math.random() * dy;        }        if (b.y > this.h + dy) {          b.vy -= Math.random() * dy;        }                if (b.z < 0 - dz) {          b.vz += Math.random() * dz;        }        if (b.z > this.d + dz) {          b.vz -= Math.random() * dz;        }        if (b.y > this.__perch_y && Math.random() < this.__perch) {          b.y = this.__perch_y;          b.vy = -Math.abs(b.vy) * 0.2;          b.is_perching = true;          b.perch_timer = this.__perch_timer;        }      }    }    public function update(shuffle:Boolean = true):void {      // Calculates the next motion frame for the flock.      // Shuffling the list of boids ensures fluid movement.      // If you need the boids to retain their position in the list each       // update, set the shuffle parameter to false.      if (shuffle) {        this.shuffle();      }           var m1:Number = 1.0; // Cohesion      var m2:Number = 1.0; // Separation      var m3:Number = 1.0; // Alignment      var m4:Number = 1.0; // Goal      // The flock scatters randomly with a Boids.scatter chance.      // This means their cohesion (m1) is reversed, and their joint alignment       // (m3) is dimished, causing boids to oscillate in confusion. Setting      // Boids.scatter(chance = 0) ensures they never scatter.      if (!this.scattered && Math.random() < this.__scatter) {        this.scattered = true;      }           if (this.scattered) {        m1 = -m1;        m3 *= 0.25;        this.__scatter_i ++;      }           if (this.__scatter_i >= this.__scatter_timer) {        this.scattered = false;        this.__scatter_i = 0;      }             // A flock can have a goal defined with Boids.goal(x,y,z), a place of       // interest to flock around.      if (!this.has_goal) {        m4 = 0;      }      if (this.flee) {        m4 = -m4;      }      for each (var b:Boid in this.boids) {        // A boid that is perching will continue to do so until         // Boid.__perch_timer reaches zero.        if (b.is_perching) {          if (b.perch_timer > 0) {            b.perch_timer --;            continue;          }          else {            b.is_perching = false;          }        }        var c:Array = b.cohesion();        b.vx += (m1 * c[0])        b.vy += (m1 * c[1])        b.vz += (m1 * c[2])        var s:Array = b.separation();        b.vx += (m2 * s[0])        b.vy += (m2 * s[1])        b.vz += (m2 * s[2])        var a:Array = b.alignment();        b.vx += (m3 * a[0])        b.vy += (m3 * a[1])        b.vz += (m3 * a[2])        if (this.has_goal) {          var g:Array = b.goal(this.__gx, this.__gy, this.__gz);          b.vx += (m4 * g[0])          b.vy += (m4 * g[1])          b.vz += (m4 * g[2])        }        b.limit(this.l);        b.x += b.vx;        b.y += b.vy;        b.z += b.vz;      }      this.constrain();    }    private function shuffle():void {      var i:uint = this.boids.length;       if (i == 0) return;            while (--i) {        var j:Number = Math.floor(Math.random() * (i + 1));        var b1:Boid = this.boids[i];        var b2:Boid = this.boids[j];        this.boids[i] = b2;        this.boids[j] = b1;      }    }  }  }