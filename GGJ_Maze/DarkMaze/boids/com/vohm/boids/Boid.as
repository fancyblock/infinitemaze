/** * Boid * Author: Andrew White <andrew@vohm.com> * * ActionScript 3.0 port of the NodeBox Boids library by * Tom De Smedt <tomdesmedt@trapdoor.be> * See: http://nodebox.net/code/index.php/Boids for info and usage. * * For the original pseucode the algorithm is based on: * http://www.vergenet.net/~conrad/boids/pseudocode.html**/package com.vohm.boids {  public class Boid {      public var boids:Array;    public var x:Number;    public var y:Number;    public var z:Number;    public var vx:Number;    public var vy:Number;    public var vz:Number;      public var is_perching:Boolean = false;    public var perch_timer:Number;      public function Boid(boids:Array, x:Number, y:Number, z:Number) {      this.boids = boids;      this.x = x;      this.y = y;      this.z = z;      this.vx = 0;      this.vy = 0;      this.vz = 0;    }        public function cohesion(d:Number = 100):Array {      // Boids move towards the flock's centre of mass. The centre of mass is       // the average position of all boids, not including itself (the "perceived      // centre").      var vx1:Number = 0;      var vy1:Number = 0;      var vz1:Number = 0;      for each (var b:Boid in this.boids) {        if (b != this) {          vx1 += b.x;          vy1 += b.y;          vz1 += b.z;        }      }          var n:Number = this.boids.length - 1;      vx1 /= n;      vy1 /= n;      vz1 /= n;          return new Array(        (vx1 - this.x) / d,         (vy1 - this.y) / d,         (vz1 - this.z) / d      );     }        public function separation(r:Number = 10):Array {      // Boids keep a small distance from other boids. Ensures that boids don't       // collide into each other, in a smoothly accelerated motion.      var vx1:Number = 0;      var vy1:Number = 0;      var vz1:Number = 0;          for each (var b:Boid in this.boids) {        if (b != this) {          if (Math.abs(this.x - b.x) < r) {            vx1 += (this.x - b.x);          }          if (Math.abs(this.y - b.y) < r) {            vy1 += (this.y - b.y);          }          if (Math.abs(this.z - b.z) < r) {            vz1 += (this.z - b.z);          }        }      }          return new Array(vx1, vy1, vz1);    }    public function alignment(d:Number = 5):Array {      // Boids match velocity with other boids.          var vx1:Number = 0;      var vy1:Number = 0;      var vz1:Number = 0;          for each (var b:Boid in this.boids) {        if (b != this) {          vx1 += b.vx;          vy1 += b.vy;          vz1 += b.vz;        }      }          var n:Number = this.boids.length - 1;      vx1 /= n;      vy1 /= n;      vz1 /= n;          return new Array(        (vx1 - this.vx) / d,         (vy1 - this.vy) / d,         (vz1 - this.vz) / d      );    }    public function limit(max:Number = 10):void {      // The speed limit for a boid. Boids can momentarily go very fast,       // something that is impossible for real animals.      if (Math.abs(this.vx) > max) {        this.vx = this.vx / Math.abs(this.vx) * max;      }      if (Math.abs(this.vy) > max) {         this.vy = this.vy / Math.abs(this.vy) * max;      }      if (Math.abs(this.vz) > max) {         this.vz = this.vz / Math.abs(this.vz) * max;      }       }    public function angle():Number {      // Returns the angle towards which the boid is steering.      // TODO: Add in z axis?      var a:Number = (Math.atan(this.vy / this.vx)) * (180 / Math.PI) + 360;          if (this.vx < 0) {        a += 180;      }      return a;    }    public function goal(x:Number, y:Number, z:Number, d:Number = 50.0):Array {      // Tendency towards a particular place.          return new Array(        (x - this.x) / d,         (y - this.y) / d,         (z - this.z) / d      );    }  }}